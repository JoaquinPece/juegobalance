<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clasificador de Balance - Contabilidad Interactiva</title>
    
    <meta name="description" content="Aprende contabilidad de forma divertida. Clasifica elementos del balance con tips educativos.">
    <meta name="keywords" content="contabilidad, balance, educaci√≥n, bachillerato">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        input, select, textarea, button { font-size: 16px; }
        @media (max-width: 768px) { .mobile-text { font-size: 0.875rem; } }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="text/babel">
const { useState, useEffect, useRef } = window.React;

        // ICONOS
        const CheckCircle = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
        const XCircle = () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
        const RotateCcw = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>;
        const Trophy = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v5l-3-1 3-1 3 1-3 1zm0 0l-.5-3H12l-.5 3z" /></svg>;
        const Volume2 = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M9 5H7a2 2 0 00-2 2v6a2 2 0 002 2h2l5 5V0L9 5z" /></svg>;
        const Clock = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
        const BookOpen = () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>;
        const Zap = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>;
        const Target = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>;

        // ELEMENTOS DEL BALANCE (30 elementos nivel Bachillerato)
        const balanceElements = [
            { name: 'Existencias', category: 'activo-corriente', description: 'Mercader√≠as, materias primas, productos terminados', tip: 'Las existencias son bienes que la empresa tiene para vender o transformar' },
            { name: 'Clientes', category: 'activo-corriente', description: 'Deudores por ventas a cr√©dito', tip: 'Los clientes nos deben dinero por ventas realizadas' },
            { name: 'Proveedores', category: 'pasivo-corriente', description: 'Deudas por compras a cr√©dito', tip: 'Debemos dinero a proveedores por compras realizadas' },
            { name: 'Capital Social', category: 'fondos-propios', description: 'Aportaciones de los socios', tip: 'Es el dinero que los due√±os han puesto en la empresa' },
            { name: 'Reservas', category: 'fondos-propios', description: 'Beneficios no distribuidos', tip: 'Son ganancias que se quedan en la empresa para fortalecerla' },
            { name: 'Inmovilizado Material', category: 'activo-no-corriente', description: 'Edificios, maquinaria, equipos', tip: 'Son bienes que duran m√°s de un a√±o en la empresa' },
            { name: 'Bancos', category: 'activo-corriente', description: 'Dinero en cuentas bancarias', tip: 'Es dinero que tenemos en el banco, muy l√≠quido' },
            { name: 'Caja', category: 'activo-corriente', description: 'Dinero en efectivo', tip: 'Es el dinero f√≠sico que tenemos en la empresa' },
            { name: 'Pr√©stamos a Largo Plazo', category: 'pasivo-no-corriente', description: 'Deudas con vencimiento superior a un a√±o', tip: 'Son deudas que pagaremos en m√°s de un a√±o' },
            { name: 'Pr√©stamos a Corto Plazo', category: 'pasivo-corriente', description: 'Deudas con vencimiento inferior a un a√±o', tip: 'Son deudas que debemos pagar pronto (menos de un a√±o)' },
            { name: 'Acreedores', category: 'pasivo-corriente', description: 'Deudas por servicios recibidos', tip: 'Debemos dinero por servicios que ya recibimos' },
            { name: 'IVA Soportado', category: 'activo-corriente', description: 'IVA pagado en las compras', tip: 'Es IVA que pagamos y podemos recuperar de Hacienda' },
            { name: 'IVA Repercutido', category: 'pasivo-corriente', description: 'IVA cobrado en las ventas', tip: 'Es IVA que cobramos y debemos entregar a Hacienda' },
            { name: 'Amortizaci√≥n Acumulada', category: 'activo-no-corriente', description: 'P√©rdida de valor del inmovilizado', tip: 'Resta valor al inmovilizado por su desgaste con el tiempo' },
            { name: 'Resultado del Ejercicio', category: 'fondos-propios', description: 'Beneficio o p√©rdida del a√±o', tip: 'Es lo que gan√≥ o perdi√≥ la empresa este a√±o' },
            { name: 'Inversiones Financieras L/P', category: 'activo-no-corriente', description: 'Inversiones a largo plazo', tip: 'Son inversiones que mantendremos m√°s de un a√±o' },
            { name: 'Deudores', category: 'activo-corriente', description: 'Otros deudores diversos', tip: 'Personas que nos deben dinero por otros conceptos' },
            { name: 'Hacienda P√∫blica Deudora', category: 'activo-corriente', description: 'Cr√©ditos con la administraci√≥n', tip: 'El Estado nos debe dinero (devoluciones, subvenciones)' },
            { name: 'Hacienda P√∫blica Acreedora', category: 'pasivo-corriente', description: 'Deudas con la administraci√≥n', tip: 'Debemos dinero al Estado (impuestos pendientes)' },
            { name: 'Anticipos de Clientes', category: 'pasivo-corriente', description: 'Pagos adelantados de clientes', tip: 'Los clientes nos pagaron antes de entregarles el producto' },
            { name: 'Terrenos', category: 'activo-no-corriente', description: 'Solares y terrenos de la empresa', tip: 'Los terrenos no se deprecian, mantienen su valor' },
            { name: 'Construcciones', category: 'activo-no-corriente', description: 'Edificios y naves industriales', tip: 'Son construcciones que duran muchos a√±os' },
            { name: 'Maquinaria', category: 'activo-no-corriente', description: 'Equipos de producci√≥n', tip: 'M√°quinas que se usan para producir durante a√±os' },
            { name: 'Mobiliario', category: 'activo-no-corriente', description: 'Muebles y enseres de oficina', tip: 'Muebles que duran m√°s de un a√±o en la empresa' },
            { name: 'Equipos Inform√°ticos', category: 'activo-no-corriente', description: 'Ordenadores y equipos IT', tip: 'Tecnolog√≠a que se usa durante varios a√±os' },
            { name: 'Efectos a Cobrar', category: 'activo-corriente', description: 'Letras de cambio a favor', tip: 'Documentos que garantizan el cobro de deudas' },
            { name: 'Efectos a Pagar', category: 'pasivo-corriente', description: 'Letras de cambio en contra', tip: 'Documentos que garantizan el pago de deudas' },
            { name: 'Sueldos Pendientes de Pago', category: 'pasivo-corriente', description: 'N√≥minas devengadas no pagadas', tip: 'Dinero que debemos a los trabajadores' },
            { name: 'Seguridad Social Acreedora', category: 'pasivo-corriente', description: 'Cotizaciones pendientes', tip: 'Debemos dinero a la Seguridad Social' },
            { name: 'Inversiones Financieras C/P', category: 'activo-corriente', description: 'Inversiones a corto plazo', tip: 'Inversiones que podemos convertir en dinero pronto' }
        ];

        // CATEGOR√çAS DEL BALANCE
        const categories = {
            'activo-corriente': { name: 'Activo Corriente', color: 'bg-green-100 border-green-300 text-green-800', description: 'Bienes y derechos que se convierten en dinero en menos de un a√±o' },
            'activo-no-corriente': { name: 'Activo No Corriente', color: 'bg-blue-100 border-blue-300 text-blue-800', description: 'Bienes y derechos de car√°cter permanente (m√°s de un a√±o)' },
            'pasivo-corriente': { name: 'Pasivo Corriente', color: 'bg-red-100 border-red-300 text-red-800', description: 'Deudas y obligaciones con vencimiento inferior a un a√±o' },
            'pasivo-no-corriente': { name: 'Pasivo No Corriente', color: 'bg-orange-100 border-orange-300 text-orange-800', description: 'Deudas y obligaciones con vencimiento superior a un a√±o' },
            'fondos-propios': { name: 'Fondos Propios', color: 'bg-purple-100 border-purple-300 text-purple-800', description: 'Recursos propios de la empresa (capital y reservas)' }
        };
// COMPONENTE PRINCIPAL
        const BalanceClassifierApp = () => {
            // ESTADOS DEL JUEGO
            const [currentElement, setCurrentElement] = useState(null);
            const [score, setScore] = useState(0);
            const [attempts, setAttempts] = useState(0);
            const [feedback, setFeedback] = useState('');
            const [showFeedback, setShowFeedback] = useState(false);
            const [usedElements, setUsedElements] = useState(new Set());
            const [gameFinished, setGameFinished] = useState(false);
            const [audioEnabled, setAudioEnabled] = useState(true);
            const [musicEnabled, setMusicEnabled] = useState(false);
            const [timeEnabled, setTimeEnabled] = useState(false);
            const [timeLeft, setTimeLeft] = useState(15);
            const [gameMode, setGameMode] = useState('exam');
            const [streak, setStreak] = useState(0);
            const [bestStreak, setBestStreak] = useState(0);
            const [showTip, setShowTip] = useState(false);
            const [isAnimating, setIsAnimating] = useState(false);

            const timerRef = useRef(null);
            const musicRef = useRef(null);
            const TOTAL_QUESTIONS = 10;
            const TIME_PER_QUESTION = 15;

            // FUNCIONES DE AUDIO
            const createBackgroundMusic = () => {
                if (!musicEnabled || !audioEnabled) return null;
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const playNote = (frequency, startTime, duration, volume = 0.04) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.frequency.setValueAtTime(frequency, startTime);
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.05);
                        gainNode.gain.linearRampToValueAtTime(volume * 0.8, startTime + duration - 0.1);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                        oscillator.start(startTime);
                        oscillator.stop(startTime + duration);
                    };
                    // Himno de la Alegr√≠a
                    const notes = [
                        { freq: 329.63, duration: 0.5 }, { freq: 329.63, duration: 0.5 },
                        { freq: 349.23, duration: 0.5 }, { freq: 392.00, duration: 0.5 },
                        { freq: 392.00, duration: 0.5 }, { freq: 349.23, duration: 0.5 },
                        { freq: 329.63, duration: 0.5 }, { freq: 293.66, duration: 0.5 },
                        { freq: 261.63, duration: 0.5 }, { freq: 261.63, duration: 0.5 },
                        { freq: 293.66, duration: 0.5 }, { freq: 329.63, duration: 0.6 },
                        { freq: 293.66, duration: 0.4 }, { freq: 293.66, duration: 1.0 }
                    ];
                    const playMelody = () => {
                        if (!musicEnabled || !audioEnabled || gameFinished) return;
                        const currentTime = audioContext.currentTime;
                        let totalTime = 0;
                        notes.forEach((note) => {
                            playNote(note.freq, currentTime + totalTime, note.duration);
                            totalTime += note.duration;
                        });
                    };
                    playMelody();
                    const intervalId = setInterval(() => {
                        if (musicEnabled && audioEnabled && !gameFinished) {
                            playMelody();
                        } else {
                            clearInterval(intervalId);
                        }
                    }, 10000);
                    return { intervalId, audioContext };
                } catch (error) {
                    console.log('M√∫sica no disponible');
                    return null;
                }
            };

            const playEnhancedSound = (type) => {
                if (!audioEnabled) return;
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (type === 'correct') {
                        [0, 0.1, 0.2, 0.3].forEach((time, index) => {
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            const frequencies = [523.25, 659.25, 783.99, 1046.5];
                            oscillator.frequency.setValueAtTime(frequencies[index], audioContext.currentTime + time);
                            oscillator.type = 'sine';
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + time);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + 0.2);
                            oscillator.start(audioContext.currentTime + time);
                            oscillator.stop(audioContext.currentTime + time + 0.2);
                        });
                    } else if (type === 'incorrect') {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(200, audioContext.currentTime + 0.3);
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                    } else if (type === 'timeout') {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime + 0.1);
                        oscillator.frequency.setValueAtTime(200, audioContext.currentTime + 0.2);
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }
                } catch (error) {
                    console.log('Audio no disponible');
                }
            };
// EFECTOS Y L√ìGICA PRINCIPAL
            useEffect(() => {
                if (timeEnabled && !showFeedback && !gameFinished && currentElement && timeLeft > 0) {
                    timerRef.current = setTimeout(() => {
                        setTimeLeft(timeLeft - 1);
                    }, 1000);
                } else if (timeEnabled && timeLeft === 0 && !showFeedback) {
                    handleTimeout();
                }
                return () => {
                    if (timerRef.current) {
                        clearTimeout(timerRef.current);
                    }
                };
            }, [timeLeft, timeEnabled, showFeedback, gameFinished, currentElement]);

            useEffect(() => {
                if (musicEnabled && audioEnabled && !gameFinished) {
                    musicRef.current = createBackgroundMusic();
                } else if (musicRef.current) {
                    try {
                        if (musicRef.current.intervalId) {
                            clearInterval(musicRef.current.intervalId);
                        }
                        musicRef.current = null;
                    } catch (error) {
                        console.log('Error deteniendo m√∫sica');
                    }
                }
                return () => {
                    if (musicRef.current) {
                        try {
                            if (musicRef.current.intervalId) {
                                clearInterval(musicRef.current.intervalId);
                            }
                        } catch (error) {
                            console.log('Error en cleanup de m√∫sica');
                        }
                    }
                };
            }, [musicEnabled, audioEnabled, gameFinished]);

            useEffect(() => {
                startNewRound();
            }, []);

            // FUNCIONES DEL JUEGO
            const scrollToTop = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            const getRandomElement = () => {
                const availableElements = balanceElements.filter(el => !usedElements.has(el.name));
                if (availableElements.length === 0) {
                    if (gameMode === 'practice') {
                        setUsedElements(new Set());
                        return balanceElements[Math.floor(Math.random() * balanceElements.length)];
                    }
                    return null;
                }
                return availableElements[Math.floor(Math.random() * availableElements.length)];
            };

            const startNewRound = () => {
                if (gameMode === 'exam' && attempts >= TOTAL_QUESTIONS) {
                    setGameFinished(true);
                    scrollToTop();
                    return;
                }
                const element = getRandomElement();
                if (!element && gameMode === 'exam') {
                    setGameFinished(true);
                    scrollToTop();
                    return;
                }
                setIsAnimating(true);
                setTimeout(() => {
                    setCurrentElement(element);
                    setShowFeedback(false);
                    setShowTip(false);
                    setFeedback('');
                    setTimeLeft(TIME_PER_QUESTION);
                    setIsAnimating(false);
                }, 300);
            };

            const handleTimeout = () => {
                if (!currentElement || showFeedback) return;
                const newUsedElements = new Set([...usedElements, currentElement.name]);
                setUsedElements(newUsedElements);
                setAttempts(attempts + 1);
                setStreak(0);
                setFeedback(`‚è∞ ¬°Tiempo agotado! ${currentElement.name} pertenece a ${categories[currentElement.category].name}.`);
                setShowTip(true);
                setShowFeedback(true);
                playEnhancedSound('timeout');
                scrollToTop();
                setTimeout(() => {
                    if (gameMode === 'exam' && attempts + 1 >= TOTAL_QUESTIONS) {
                        setGameFinished(true);
                        scrollToTop();
                    } else {
                        startNewRound();
                    }
                }, 4000);
            };

            const handleCategoryClick = (selectedCategory) => {
                if (!currentElement || showFeedback) return;
                const newUsedElements = new Set([...usedElements, currentElement.name]);
                setUsedElements(newUsedElements);
                setAttempts(attempts + 1);
                const isCorrect = selectedCategory === currentElement.category;
                scrollToTop();
                if (isCorrect) {
                    setScore(score + 1);
                    const newStreak = streak + 1;
                    setStreak(newStreak);
                    if (newStreak > bestStreak) {
                        setBestStreak(newStreak);
                    }
                    setFeedback(`¬°Correcto! ${currentElement.name} pertenece a ${categories[selectedCategory].name}.`);
                    playEnhancedSound('correct');
                } else {
                    setStreak(0);
                    setFeedback(`Incorrecto. ${currentElement.name} pertenece a ${categories[currentElement.category].name}.`);
                    setShowTip(true);
                    playEnhancedSound('incorrect');
                }
                setShowFeedback(true);
                setTimeout(() => {
                    if (gameMode === 'exam' && attempts + 1 >= TOTAL_QUESTIONS) {
                        setGameFinished(true);
                        scrollToTop();
                    } else {
                        startNewRound();
                    }
                }, 4000);
            };

            const resetGame = () => {
                setScore(0);
                setAttempts(0);
                setStreak(0);
                setUsedElements(new Set());
                setShowFeedback(false);
                setShowTip(false);
                setGameFinished(false);
                setTimeLeft(TIME_PER_QUESTION);
                startNewRound();
                scrollToTop();
            };

            const switchGameMode = (mode) => {
                setGameMode(mode);
                resetGame();
            };

            const accuracy = attempts > 0 ? Math.round((score / attempts) * 100) : 0;

            const getGrade = () => {
                if (gameMode === 'practice') {
                    return { grade: '‚àû', message: '¬°Sigue practicando!', color: 'text-blue-600', emoji: 'üìö' };
                }
                if (score >= 9) return { grade: 'A+', message: '¬°Excelente! Dominas perfectamente el balance', color: 'text-green-600', emoji: 'üèÜ' };
                if (score >= 8) return { grade: 'A', message: '¬°Muy bien! Tienes un gran conocimiento', color: 'text-green-500', emoji: '‚≠ê' };
                if (score >= 7) return { grade: 'B+', message: 'Buen trabajo, sigue practicando', color: 'text-blue-500', emoji: 'üëç' };
                if (score >= 6) return { grade: 'B', message: 'Bien, pero puedes mejorar', color: 'text-blue-400', emoji: 'üìö' };
                if (score >= 5) return { grade: 'C', message: 'Aprobado, necesitas m√°s pr√°ctica', color: 'text-yellow-500', emoji: 'üìñ' };
                return { grade: 'F', message: 'Repasa los conceptos y vuelve a intentar', color: 'text-red-500', emoji: 'üìù' };
            };
// RENDER DE LA INTERFAZ
            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
                    <div className="max-w-4xl mx-auto">
                        
                        {/* HEADER */}
                        <div className="text-center mb-6 md:mb-8 fade-in">
                            <h1 className="text-2xl md:text-3xl font-bold text-gray-800 mb-2">
                                üìä Clasificador de Balance
                            </h1>
                            <p className="text-sm md:text-base text-gray-600">
                                Practica la clasificaci√≥n de elementos del balance - {balanceElements.length} elementos disponibles
                            </p>
                        </div>

                        {/* SELECTOR DE MODO */}
                        <div className="bg-white rounded-lg shadow-md p-4 mb-6 fade-in">
                            <div className="flex justify-center space-x-4 mb-4">
                                <button
                                    onClick={() => switchGameMode('exam')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition-all text-sm md:text-base ${
                                        gameMode === 'exam' ? 'bg-blue-500 text-white shadow-lg' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                    }`}
                                >
                                    <Trophy />
                                    <span>Modo Examen</span>
                                </button>
                                <button
                                    onClick={() => switchGameMode('practice')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition-all text-sm md:text-base ${
                                        gameMode === 'practice' ? 'bg-green-500 text-white shadow-lg' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                    }`}
                                >
                                    <BookOpen />
                                    <span>Modo Pr√°ctica</span>
                                </button>
                            </div>
                            <div className="flex justify-center space-x-6 text-sm">
                                <label className="flex items-center space-x-2">
                                    <input type="checkbox" checked={timeEnabled} onChange={(e) => setTimeEnabled(e.target.checked)} className="rounded" />
                                    <Clock />
                                    <span>Tiempo l√≠mite</span>
                                </label>
                                <label className="flex items-center space-x-2">
                                    <input type="checkbox" checked={musicEnabled} onChange={(e) => setMusicEnabled(e.target.checked)} className="rounded" />
                                    <span>üéµ M√∫sica</span>
                                </label>
                            </div>
                        </div>

                        {/* PANEL DE PUNTUACI√ìN */}
                        <div className="bg-white rounded-lg shadow-md p-4 mb-6 fade-in">
                            <div className="flex justify-between items-center flex-wrap gap-4">
                                <div className="flex items-center space-x-4 flex-wrap">
                                    {gameMode === 'exam' && (
                                        <div className="flex items-center space-x-2">
                                            <Trophy />
                                            <span className="font-semibold text-sm md:text-base">Pregunta: {attempts}/{TOTAL_QUESTIONS}</span>
                                        </div>
                                    )}
                                    <div className="flex items-center space-x-2">
                                        <span className="font-semibold text-sm md:text-base">Puntuaci√≥n: {score}{gameMode === 'exam' ? `/${attempts}` : ''}</span>
                                    </div>
                                    {streak > 0 && (
                                        <div className="flex items-center space-x-2">
                                            <Zap />
                                            <span className="font-semibold text-orange-500 text-sm md:text-base">Racha: {streak}</span>
                                        </div>
                                    )}
                                    {bestStreak > 0 && (
                                        <div className="flex items-center space-x-2">
                                            <Target />
                                            <span className="text-purple-500 text-sm">Mejor: {bestStreak}</span>
                                        </div>
                                    )}
                                    {attempts > 0 && gameMode === 'exam' && (
                                        <div className="text-sm text-gray-600">Precisi√≥n: {accuracy}%</div>
                                    )}
                                </div>
                                <div className="flex items-center space-x-2">
                                    <button
                                        onClick={() => setAudioEnabled(!audioEnabled)}
                                        className={`p-2 rounded-lg transition-colors ${audioEnabled ? 'bg-green-100 text-green-600' : 'bg-gray-100 text-gray-400'}`}
                                        title={audioEnabled ? 'Desactivar sonido' : 'Activar sonido'}
                                    >
                                        <Volume2 />
                                    </button>
                                    <button
                                        onClick={resetGame}
                                        className="flex items-center space-x-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors text-sm md:text-base"
                                    >
                                        <RotateCcw />
                                        <span>Reiniciar</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* TEMPORIZADOR */}
                        {timeEnabled && !gameFinished && currentElement && (
                            <div className="bg-white rounded-lg shadow-md p-4 mb-6 fade-in">
                                <div className="flex items-center justify-center space-x-3">
                                    <Clock className={`w-5 h-5 ${timeLeft <= 5 ? 'text-red-500' : 'text-blue-500'}`} />
                                    <div className="flex-1 bg-gray-200 rounded-full h-3">
                                        <div 
                                            className={`h-3 rounded-full transition-all duration-1000 ${timeLeft <= 5 ? 'bg-red-500' : 'bg-blue-500'}`}
                                            style={{ width: `${(timeLeft / TIME_PER_QUESTION) * 100}%` }}
                                        ></div>
                                    </div>
                                    <span className={`font-bold ${timeLeft <= 5 ? 'text-red-500' : 'text-blue-500'}`}>{timeLeft}s</span>
                                </div>
                            </div>
                        )}

                        {/* PANTALLA DE JUEGO TERMINADO */}
                        {gameFinished ? (
                            <div className="bg-white rounded-lg shadow-md p-6 md:p-8 mb-6 text-center fade-in">
                                <div className="text-4xl md:text-6xl mb-4">{getGrade().emoji}</div>
                                <h2 className="text-2xl md:text-3xl font-bold text-gray-800 mb-2">¬°Partida Terminada!</h2>
                                <div className={`text-3xl md:text-4xl font-bold mb-4 ${getGrade().color}`}>Calificaci√≥n: {getGrade().grade}</div>
                                <p className="text-lg md:text-xl text-gray-600 mb-4">{getGrade().message}</p>
                                <div className="bg-gray-50 rounded-lg p-4 mb-6">
                                    <div className="text-lg font-semibold text-gray-800">Resultados Finales:</div>
                                    <div className="text-2xl md:text-3xl font-bold text-blue-600 mt-2">{score} / {TOTAL_QUESTIONS}</div>
                                    <div className="text-gray-600">Precisi√≥n: {accuracy}%</div>
                                    {bestStreak > 0 && <div className="text-purple-600 mt-1">Mejor racha: {bestStreak}</div>}
                                </div>
                                <button onClick={resetGame} className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-lg font-semibold">
                                    üéØ Nueva Partida
                                </button>
                            </div>
                        ) : (
                            /* ELEMENTO ACTUAL */
                            currentElement && (
                                <div className={`bg-white rounded-lg shadow-md p-4 md:p-6 mb-6 text-center transition-all duration-300 ${isAnimating ? 'opacity-0 transform scale-95' : 'opacity-100 transform scale-100'}`}>
                                    <h2 className="text-xl md:text-2xl font-bold text-gray-800 mb-2">{currentElement.name}</h2>
                                    <p className="text-gray-600 mb-4 text-sm md:text-base mobile-text">{currentElement.description}</p>
                                    <p className="text-lg font-medium text-blue-600">¬øA qu√© masa patrimonial pertenece?</p>
                                    {streak >= 3 && (
                                        <div className="mt-2 text-orange-500 font-bold animate-pulse">üî• ¬°Racha de {streak}! ¬°Sigue as√≠!</div>
                                    )}
                                </div>
                            )
                        )}

                        {/* FEEDBACK */}
                        {showFeedback && (
                            <div className={`rounded-lg p-4 mb-6 flex items-start space-x-3 transition-all duration-500 ${
                                feedback.includes('Correcto') || feedback.includes('¬°Correcto!') ? 'bg-green-100 border border-green-300 text-green-800' : 'bg-red-100 border border-red-300 text-red-800'
                            }`}>
                                {feedback.includes('Correcto') || feedback.includes('¬°Correcto!') ? <CheckCircle /> : <XCircle />}
                                <div className="flex-1">
                                    <p className="font-medium text-sm md:text-base mobile-text">{feedback}</p>
                                    {showTip && currentElement && (
                                        <div className="mt-3 p-3 bg-blue-50 rounded-lg border-l-4 border-blue-400">
                                            <div className="flex items-start space-x-2">
                                                <span className="text-blue-500 font-bold">üí°</span>
                                                <div>
                                                    <p className="font-semibold text-blue-800 mb-1 text-sm">Tip:</p>
                                                    <p className="text-blue-700 text-xs md:text-sm mobile-text">{currentElement.tip}</p>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {/* CATEGOR√çAS */}
                        {!gameFinished && (
                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-3 fade-in">
                                {Object.entries(categories).map(([key, category]) => (
                                    <button
                                        key={key}
                                        onClick={() => handleCategoryClick(key)}
                                        disabled={showFeedback}
                                        className={`${category.color} border-2 rounded-lg p-3 text-center hover:shadow-lg transition-all duration-200 hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed min-h-[80px] md:min-h-[100px] flex flex-col justify-center transform hover:-translate-y-1`}
                                    >
                                        <h3 className="font-bold text-xs md:text-sm mb-1">{category.name}</h3>
                                        <p className="text-xs leading-tight mobile-text">{category.description}</p>
                                    </button>
                                ))}
                            </div>
                        )}

                        {/* INSTRUCCIONES */}
                        <div className="mt-6 bg-white rounded-lg shadow-md p-4 fade-in">
                            <h3 className="text-base md:text-lg font-bold text-gray-800 mb-2">üí° Instrucciones</h3>
                            <div className="text-gray-600 text-xs md:text-sm space-y-1 mobile-text">
                                <p>‚Ä¢ <strong>Modo Examen:</strong> 10 preguntas sin repetici√≥n con calificaci√≥n final</p>
                                <p>‚Ä¢ <strong>Modo Pr√°ctica:</strong> Preguntas ilimitadas para mejorar tus conocimientos</p>
                                <p>‚Ä¢ <strong>Tiempo l√≠mite:</strong> Act√≠valo para mayor desaf√≠o (15 segundos por pregunta)</p>
                                <p>‚Ä¢ <strong>Rachas:</strong> Consigue 3+ respuestas correctas seguidas para motivaci√≥n extra</p>
                                <p>‚Ä¢ <strong>Tips:</strong> Aprende de tus errores con consejos autom√°ticos</p>
                                <p>‚Ä¢ <strong>M√∫sica:</strong> Himno de la Alegr√≠a de Beethoven de fondo üéµ</p>
                            </div>
                        </div>

                        {/* ESTAD√çSTICAS MODO PR√ÅCTICA */}
                        {gameMode === 'practice' && attempts > 0 && (
                            <div className="mt-6 bg-white rounded-lg shadow-md p-4 fade-in">
                                <h3 className="text-base md:text-lg font-bold text-gray-800 mb-2">üìä Estad√≠sticas de Pr√°ctica</h3>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                    <div>
                                        <div className="text-xl md:text-2xl font-bold text-blue-600">{score}</div>
                                        <div className="text-xs md:text-sm text-gray-600 mobile-text">Correctas</div>
                                    </div>
                                    <div>
                                        <div className="text-xl md:text-2xl font-bold text-purple-600">{attempts}</div>
                                        <div className="text-xs md:text-sm text-gray-600 mobile-text">Total</div>
                                    </div>
                                    <div>
                                        <div className="text-xl md:text-2xl font-bold text-green-600">{accuracy}%</div>
                                        <div className="text-xs md:text-sm text-gray-600 mobile-text">Precisi√≥n</div>
                                    </div>
                                    <div>
                                        <div className="text-xl md:text-2xl font-bold text-orange-600">{bestStreak}</div>
                                        <div className="text-xs md:text-sm text-gray-600 mobile-text">Mejor racha</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* FOOTER */}
                        <div className="mt-8 text-center text-gray-500 text-xs md:text-sm fade-in">
                            <p>üéì Herramienta educativa para 2¬∫ Bachillerato ‚Ä¢ üì± Compatible con m√≥viles y PC ‚Ä¢ üÜì Gratuito y sin registro</p>
                        </div>
                    </div>
                </div>
            );
        };

        // RENDERIZAR APLICACI√ìN
        const root = window.ReactDOM.createRoot(document.getElementById('root'));
        root.render(<BalanceClassifierApp />);
    </script>
</body>
</html>